\section{Scheduler (Bộ lập lịch)}

\subsection{Trả lời câu hỏi lý thuyết}
\textbf{Câu hỏi:} Những ưu điểm của việc sử dụng thuật toán lập lịch được mô tả trong bài tập này (Multi-Level Queue - MLQ) so với các thuật toán lập lịch khác là gì?

\textbf{Trả lời:}
Thuật toán Multi-Level Queue (MLQ) được sử dụng trong bài tập này mang lại nhiều ưu điểm so với các thuật toán đơn giản như FCFS hay Round Robin thuần túy:
\begin{itemize}
    \item \textbf{Phân loại tiến trình:} MLQ cho phép phân loại các tiến trình dựa trên độ ưu tiên (priority). Các tiến trình quan trọng hoặc cần phản hồi nhanh có thể được đặt vào hàng đợi có độ ưu tiên cao hơn.
    \item \textbf{Đảm bảo độ phản hồi (Responsiveness):} Bằng cách luôn chọn tiến trình từ hàng đợi có độ ưu tiên cao nhất (nếu có), hệ thống đảm bảo các tác vụ quan trọng được xử lý ngay lập tức.
    \item \textbf{Cơ chế Slot (Time Slicing):} Việc cấp phát một số lượng slot (thời gian CPU) nhất định cho mỗi hàng đợi (trong bài tập là \texttt{MAX\_PRIO - prio}) giúp ngăn chặn tình trạng "đói tài nguyên" (starvation) hoàn toàn cho các tiến trình độ ưu tiên thấp, đồng thời vẫn duy trì được sự ưu tiên cho các tiến trình quan trọng.
\end{itemize}

\subsection{Hiện thực (Implementation)}
Hệ thống sử dụng mảng \texttt{mlq\_ready\_queue} gồm \texttt{MAX\_PRIO} (140) hàng đợi. Cơ chế lập lịch chính được hiện thực trong hàm \texttt{get\_mlq\_proc} tại file \texttt{sched.c}.

\subsubsection{Cấu trúc dữ liệu}
\begin{lstlisting}[language=C]
static struct queue_t mlq_ready_queue[MAX_PRIO];  // 140 priority queues
static int slot[MAX_PRIO];              // Time slots per priority level
static int current_slot[MAX_PRIO];      // Current slot usage tracking
static int current_prio = 0;            // Current serving priority
static pthread_mutex_t queue_lock;      // Mutex for thread-safety
\end{lstlisting}

Trong đó:
\begin{itemize}
    \item \texttt{mlq\_ready\_queue[i]}: Hàng đợi chứa các tiến trình có độ ưu tiên \texttt{i}.
    \item \texttt{slot[i] = MAX\_PRIO - i}: Số time slots được cấp cho mỗi priority level. Priority cao hơn (giá trị nhỏ hơn) được nhiều slots hơn.
    \item \texttt{current\_slot[i]}: Đếm số slots đã sử dụng cho priority \texttt{i} trong round hiện tại.
    \item \texttt{current\_prio}: Priority level đang được phục vụ (chỉ dùng để tracking).
\end{itemize}

\subsubsection{Giải thuật get\_mlq\_proc}
Giải thuật được chia thành 2 phases:

\textbf{Phase 1: Slot-based Selection}
\begin{enumerate}
    \item \textbf{Luôn duyệt từ priority 0 (highest) đến priority 139 (lowest)} để đảm bảo priority preemption.
    \item Kiểm tra điều kiện: hàng đợi không rỗng VÀ còn slots available (\texttt{current\_slot[prio] < slot[prio]}).
    \item Nếu thỏa mãn: dequeue process, tăng \texttt{current\_slot[prio]}, update \texttt{current\_prio}.
    \item Break ngay khi tìm thấy process phù hợp.
\end{enumerate}

\textbf{Phase 2: Reset \& Retry}

Nếu Phase 1 không tìm thấy process (tất cả slots đã hết):
\begin{enumerate}
    \item Reset tất cả \texttt{current\_slot[]} về 0.
    \item Thử lại từ priority 0, lần này bỏ qua điều kiện slot.
    \item Chọn process đầu tiên tìm được từ hàng đợi không rỗng.
\end{enumerate}

\textbf{Synchronization:} Sử dụng \texttt{pthread\_mutex\_lock(\&queue\_lock)} để đảm bảo thread-safety khi nhiều CPUs truy cập queues đồng thời.

\begin{lstlisting}[language=C]
struct pcb_t * get_mlq_proc(void) {
    struct pcb_t * proc = NULL;
    pthread_mutex_lock(&queue_lock);
    for (int prio = 0; prio < MAX_PRIO; prio++) {
        if (!empty(&mlq_ready_queue[prio]) && 
            current_slot[prio] < slot[prio]) {
            
            proc = dequeue(&mlq_ready_queue[prio]);
            if (proc != NULL) {
                current_slot[prio]++;
                current_prio = prio;
                break;
            }
        }
    }
    if (proc == NULL) {
        for (int i = 0; i < MAX_PRIO; i++) {
            current_slot[i] = 0;
        }
        for (int prio = 0; prio < MAX_PRIO; prio++) {
            if (!empty(&mlq_ready_queue[prio])) {
                proc = dequeue(&mlq_ready_queue[prio]);
                if (proc != NULL) {
                    current_slot[prio] = 1;
                    current_prio = prio;
                    break;
                }
            }
        }
    }
    if (proc != NULL) {
        enqueue(&running_list, proc);
    }
    pthread_mutex_unlock(&queue_lock);
    return proc;
}
\end{lstlisting}

\textbf{Đặc điểm thuật toán:}
\begin{itemize}
    \item \textbf{Priority preemption:} Mỗi lần chọn process, thuật toán duyệt từ priority 0 (highest) đến priority 139 (lowest), đảm bảo processes có priority cao hơn luôn được xử lý trước.
    \item \textbf{Slot fairness:} Phase 2 được kích hoạt khi tất cả queues có processes đã hết slots, reset bộ đếm và bắt đầu round mới, ngăn starvation cho low-priority processes.
    \item \textbf{Time complexity:} O(MAX\_PRIO) = O(140) = O(1) constant time cho mỗi lần get process.
    \item \textbf{Thread-safe:} Sử dụng mutex lock bảo vệ critical section khi truy cập shared queues trong multi-CPU environment.
\end{itemize}

\subsection{Kết quả chạy thử nghiệm}

\subsubsection{Test Case 1: sched\_0 (Priority Preemption)}
\textbf{Mục đích:} Kiểm tra cơ chế priority preemption - process có priority cao hơn phải preempt process có priority thấp hơn ngay lập tức.

\textbf{Input:} \texttt{sched\_0}
\begin{itemize}
    \item Time 0: Load P1 (PID=1, PRIO=4)
    \item Time 4: Load P2 (PID=2, PRIO=0)
\end{itemize}

\textbf{Output (rút gọn):}
\begin{verbatim}
Time slot   0
        Loaded a process at input/proc/s0, PID: 1 PRIO: 4
Time slot   1
        CPU 0: Dispatched process  1
Time slot   3
        CPU 0: Put process  1 to run queue
        CPU 0: Dispatched process  1
Time slot   4
        Loaded a process at input/proc/s1, PID: 2 PRIO: 0
Time slot   5
        CPU 0: Put process  1 to run queue
        CPU 0: Dispatched process  2    <-- P2 (PRIO=0) preempts P1 (PRIO=4)
...
Time slot  12
        CPU 0: Processed  2 has finished
        CPU 0: Dispatched process  1    <-- P1 resume after P2 finished
...
Time slot  23
        CPU 0: Processed  1 has finished
\end{verbatim}

\textbf{Phân tích kết quả:} 
\begin{itemize}
    \item \textbf{Time 0-4:} P1 (PRIO=4) được load và chạy trên CPU 0.
    \item \textbf{Time 4:} P2 (PRIO=0) được load vào hệ thống.
    \item \textbf{Time 5:} P2 được dispatch ngay lập tức, thay thế P1 - đây là behavior của priority preemption.
    \item \textbf{Time 5-12:} P2 chạy liên tục (không bị preempt vì có priority cao nhất) và hoàn thành tại time 12.
    \item \textbf{Time 12-23:} P1 được dispatch lại và chạy cho đến khi hoàn thành.
    \item \textbf{Kết luận:} Cơ chế priority preemption hoạt động đúng - process có priority cao hơn (giá trị nhỏ hơn) sẽ preempt process có priority thấp hơn ngay lập tức.
\end{itemize}

\subsubsection{Test Case 2: sched\_1 (MLQ Round-Robin)}
\textbf{Mục đích:} Kiểm tra FIFO scheduling trong cùng priority level và MLQ round-robin behavior.

\textbf{Input:} \texttt{sched\_1}
\begin{itemize}
    \item Time 0: Load P1 (PID=1, PRIO=4)
    \item Time 4: Load P2 (PID=2, PRIO=0)
    \item Time 6: Load P3 (PID=3, PRIO=0)
    \item Time 7: Load P4 (PID=4, PRIO=0)
\end{itemize}

\textbf{Output (rút gọn):}
\begin{verbatim}
Time slot   5
        CPU 0: Dispatched process  2
Time slot   7
        CPU 0: Put process  2 to run queue
        CPU 0: Dispatched process  3
Time slot   9
        CPU 0: Put process  3 to run queue
        CPU 0: Dispatched process  2    <-- Round-robin: P2->P3->P2
Time slot  11
        CPU 0: Put process  2 to run queue
        CPU 0: Dispatched process  4    <-- Continue: P2->P3->P2->P4
Time slot  13
        CPU 0: Put process  4 to run queue
        CPU 0: Dispatched process  3    <-- Pattern: P2->P3->P4->P3
...
Time slot  22
        CPU 0: Processed  2 has finished
Time slot  34
        CPU 0: Processed  3 has finished
Time slot  35
        CPU 0: Processed  4 has finished
        CPU 0: Dispatched process  1    <-- P1 chỉ chạy sau khi all PRIO=0 finished
\end{verbatim}

\textbf{Phân tích kết quả:}
\begin{itemize}
    \item \textbf{Time 0-4:} P1 (PRIO=4) được load và bắt đầu chạy.
    \item \textbf{Time 4-7:} P2, P3, P4 (tất cả PRIO=0) được load vào hệ thống.
    \item \textbf{Time 5:} P2 preempt P1 do có priority cao hơn.
    \item \textbf{Scheduling pattern:} P2→P3→P2→P4→P3→P2→P4→P3... - đây là round-robin giữa các processes cùng priority.
    \item \textbf{FIFO behavior:} Trong cùng priority 0, các processes được dispatch theo thứ tự vào queue (P2 trước P3 trước P4).
    \item \textbf{Time 22-35:} P2, P3, P4 hoàn thành lần lượt.
    \item \textbf{Time 35-46:} P1 mới được CPU sau khi tất cả processes PRIO=0 đã hoàn thành.
    \item \textbf{Kết luận:} MLQ đảm bảo FIFO trong cùng priority level và round-robin scheduling với time slice.
\end{itemize}

\subsubsection{Test Case 3: sched (Multi-CPU)}
\textbf{Mục đích:} Kiểm tra MLQ scheduling trên môi trường multi-CPU.

\textbf{Input:} \texttt{sched} (2 CPUs)
\begin{itemize}
    \item Time 0: Load P1 (PID=1, PRIO=1)
    \item Time 1: Load P2 (PID=2, PRIO=0)
    \item Time 2: Load P3 (PID=3, PRIO=0)
\end{itemize}

\textbf{Output (rút gọn):}
\begin{verbatim}
Time slot   1
        CPU 0: Dispatched process  1
        Loaded a process at input/proc/p2s, PID: 2 PRIO: 0
Time slot   2
        CPU 1: Dispatched process  2    <-- P2 on CPU1
        Loaded a process at input/proc/p3s, PID: 3 PRIO: 0
Time slot   5
        CPU 0: Put process  1 to run queue
        CPU 0: Dispatched process  3    <-- P3 preempts P1 (0 < 1)
        CPU 1: Put process  2 to run queue
        CPU 1: Dispatched process  2
...
Time slot  13
        CPU 1: Processed  2 has finished
Time slot  14
        CPU 1: Dispatched process  1    <-- P1 gets CPU1 after P2 finished
Time slot  16
        CPU 0: Processed  3 has finished
Time slot  20
        CPU 1: Processed  1 has finished
\end{verbatim}

\textbf{Phân tích kết quả:}
\begin{itemize}
    \item \textbf{Time 1:} CPU 0 dispatch P1 (PRIO=1), P2 (PRIO=0) được load.
    \item \textbf{Time 2:} CPU 1 dispatch P2 đồng thời với CPU 0, cho thấy multi-CPU hoạt động song song. P3 (PRIO=0) được load.
    \item \textbf{Time 5:} CPU 0 dispatch P3 thay vì tiếp tục P1 - priority preemption đúng (PRIO 0 < PRIO 1).
    \item \textbf{Load balancing:} Các CPUs tự động pick processes từ shared ready queues, đảm bảo CPU utilization.
    \item \textbf{Time 13-20:} P2 và P3 hoàn thành, P1 được dispatch lại trên CPU 1.
    \item \textbf{Thread safety:} Không có race conditions hay conflicts khi nhiều CPUs truy cập queues đồng thời, chứng tỏ mutex synchronization hoạt động đúng.
    \item \textbf{Kết luận:} MLQ scheduler hỗ trợ multi-CPU với thread-safe operations và load balancing tự động.
\end{itemize}

\subsubsection{Tổng kết kết quả test}
\begin{table}[h]
\centering
\begin{tabular}{|l|c|p{6cm}|}
\hline
\textbf{Test Case} & \textbf{Status} & \textbf{Verified Features} \\ \hline
sched\_0 & PASS & Priority preemption, Process resumption \\ \hline
sched\_1 & PASS & FIFO within priority, Round-robin, Slot fairness \\ \hline
sched & PASS & Multi-CPU, Load balancing, Thread-safety \\ \hline
\end{tabular}
\caption{Kết quả test scheduler}
\end{table}

Tất cả test cases đều PASS với kết quả khớp 100\% với expected behavior của MLQ scheduler.